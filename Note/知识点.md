## 零散的知识点
汇编中所有标号都仅仅是单纯的数字。每个标号对应的数字,是由汇编语言编译器根据ORG指令计算出来的。  
编译器计算出的 __“标号的地方对应的内存地址”就是那个标号的值。__  
所以可以用 "JMP entry" 代替 "JMP 0x7c50"。  
__汇编寻址__ 一般说来,如果能用一个寄存器来表示内存地址的话,当然会很方便,但一个BX只能表示0-0xfff的值,也就是只有0-65535,最大才64K,大家的电脑起码也都有64M内存,或者更多,只用一个寄存器来表示内存地址的话,就只能用64K的内存,这太可惜了。  
于是为了解决这个问题,就增加了一个叫EBX的寄存器,这样就能处理4G内存了。这是CPU能处理的最大内存量,没有任何问题。但EBX的导入是很久以后的事情,在设计BIOS的时代,CPU甚至还没有32位寄存器,所以当时只好设计了一个起辅助作用的段寄存器(segment register)。在指定内存地址的时候,可以使用这个段寄存器。  
我们使用段寄存器时,以 ES:BX 这种方式来表示地址,写成ESx16+BX的内存地址,可以指定1M内存。  
__控制点阵__ _打印条纹图案..._  
先来看看让特定位变成1的功能。这可以通过“或” (OR)运算来实现。  
0100 OR 0010 -> 0110  
1010 OR 0010 -> 1010  
让特定位变成0的功能。这可以通过“与” (AND )运算来实现。  
0100 AND 1101 -> 0100  
1010 AND 1101 -> 1000  
让特定位反转的功能。这可以通过“异或” (XOR)运算来实现。  
0100 XOR 0010 -> 0110
1010 AND 0010 -> 1000


C语言与画面显示的练习
用C语言实现内存写入(haribola)
条纹图案( harib01b)
挑战指针( harib01c)
指针应用(1) (harib0ld)
指针应用(2) (haribole)
色号设定(harib01f)
制矩形( harib01g)
今天的成果(harib01h)